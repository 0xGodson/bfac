#!/usr/bin/env python
# coding=utf-8
# *******************************************************************
# *** BFAC: Backup File Artifacts Checker ***
# * Description:
#   An automated tool that checks for backup artifacts
#   that may disclose the web-application's source code.
# * Version:
#   v1.2
# * Homepage:
#   https://github.com/mazen160/bfac
# * Author:
#   Mazin Ahmed <Mazin AT MazinAhmed DOT net>
# *******************************************************************

# Modules
from sys import argv, version_info, stdin
import random
import argparse
try:
    from urllib import parse as urlparse
except ImportError:
    import urlparse
try:
    import requests
except ImportError:
    print('[!] Error: requests module does not seem to be installed.')
    print('Use the following command to install requests module.')
    if (version_info[0] == 2):
        print('$ pip install requests')
    else:
        print('$ pip3 install requests')
    print('\nExiting...')
    exit(1)

# Disable SSL warnings
try:
    import requests.packages.urllib3
    requests.packages.urllib3.disable_warnings()
except:
    pass

# Version
version = '1.2'


class tcolor:
    """
    A simple coloring class.
    """
    endcolor = '\033[0m'
    red = '\033[31m'
    green = '\033[32m'
    purple = '\033[35m'
    yellow = '\033[93m'
    light_blue = '\033[96m'


def logo(enable_colored_logo=True):
    """
    Returns logo.
    """

    logo = ''  # Initializing the variable.
    if enable_colored_logo is False:
        """
        Uncolored Logo.
        """
        logo = """
\t\t\t\t     _____   _______  _______  _______
\t\t\t\t    (  ___ \ (  ____ \(  ___  )(  ____ \\
\t\t\t\t    | (   ) )| (    \/| (   ) || (    \/
\t\t\t\t    | (__/ / | (__    | (___) || |
\t\t\t\t    |  __ (  |  __)   |  ___  || |
\t\t\t\t    | (  \ \ | (      | (   ) || |
\t\t\t\t    | )___) )| )      | )   ( || (____/\\
\t\t\t\t    |/ \___/ |/       |/     \|(_______/

\t\t\t\t   -:::Backup File Artifacts Checker:::-
\t\t\t\t\t      version: """ + str(version) + """
\t\t\t__Advanced Backup-File Artifacts Testing for Web-Applications__
\t\t\tAuthor: Mazin Ahmed | <mazin AT mazinahmed DOT net> | @mazen160\
\n\n\n"""

    if enable_colored_logo is True:
        """
        Colored Logo.
        """
        logo = tcolor.light_blue + """
\t\t\t\t     _____   _______  _______  _______
\t\t\t\t    (  ___ \ (  ____ \(  ___  )(  ____ \\
\t\t\t\t    | (   ) )| (    \/| (   ) || (    \/
\t\t\t\t    | (__/ / | (__    | (___) || |
\t\t\t\t    |  __ (  |  __)   |  ___  || |
\t\t\t\t    | (  \ \ | (      | (   ) || |
\t\t\t\t    | )___) )| )      | )   ( || (____/\\
\t\t\t\t    |/ \___/ |/       |/     \|(_______/
""" + tcolor.yellow + """
\t\t\t\t   -:::Backup File Artifacts Checker:::-
\t\t\t\t\t      version: """ + str(version) + """
\t\t\t__Advanced Backup-File Artifacts Testing for Web-Applications__
\t\t\tAuthor: Mazin Ahmed | <mazin AT mazinahmed DOT net> | @mazen160\
\n\n\n"""\
+ tcolor.endcolor

    return(logo)


def instructions():
    """
    Returns command-line instructions for using BFAC.
    """

    instructions = """
        Arguments:-

    * Target Options
-u, --url URL               Check a single URL.
-l, --list LIST             Check a list of URLs.
--stdin                     Checks URLs from STDIN input.

    * Testing Options
-level, --level LEVEL       Set testing level [0-4] (Default: 4).
--dvcs-test DVCS_TEST       Performs only DVCS testing, which is also\
 available by default on Level 4.

    * Artifacts Detection Options
-vsc, --valid-status-codes VALID_STATUS_CODES
                            Specify valid status codes for checks,\
 seperated by commas.(Default: 200).
-isc, --invalid-status-codes INVALID_STATUS_CODES
                            Specify invalid status codes for checks,\
 seperated by commas.(Default: 403,404).
-icl, --invalid-content-length INVALID_CONTENT_LENGTH
                            Manually specify the invalid\
 Content-Length, instead of performing this check automatically.
--content-length-range CONTENT_LENGTH_RANGE
                            Manually specify the Content-Length\
 range for invalid pages. (Default: 50)
--verify-file-availability VERIFY_FILE_AVAILABILITY
                            Method to verify the availability\
 of the file. (Options: status_code, content_length, both)\
  (Default: both)
-xsc, --exclude-status-codes EXCLUDE_STATUS_CODES
                            Specify status codes to exclude,\
 seperated by commas.

    * Requests-Related Options
-ua, --user-agent USER_AGENT    HTTP User-Agent header value.
-ra, --random-agent             Use random User-Agents.
--cookie COOKIE                 HTTP Cookie header value.
--host HOST                     HTTP Host header value.
--headers HEADERS               Extra headers\
 (e.g. "Accept-Language: fr\\nETag: 123")
--proxy PROXY                   Use a proxy on testing.
--proxy-cred PROXY_CRED         Proxy authentication credentials\
(name:password)
--timeout TIMEOUT               HTTP Request timeout by seconds.\
 (Default: 5)

    * Output-Related Options
-o, --output OUTPUT             Save identified URLs into a file.
--verbose-output OUTPUT         Save identified URLs, with \
status-codes and content-length into a file.

    * Other Options
-h, --help                      Show this help message and exit.
--no-text                       Prints and writes a clean output\
with only results.
--api                           Shows findings in JSON,\
 suitable for APIs.
-v, --verbose                   Enable verbosity.
--debug                         Enables debugging.
-V, --version                   Show current version and exit.
"""
    return(instructions)


# Handling custom messages (command-line use)
if (__name__ == '__main__'):
    if (not('--no-text' in argv) and not('-api' in argv) and
       not('--api' in argv)):

        if (('-h' in argv) or ('--help' in argv) or ('-hh' in argv) or
                (len(argv) <= 1) or ('-help' in argv) or
                ('--h' in argv)):

            print(logo(enable_colored_logo=True))
            print(instructions())
            exit(0)
        else:
            print(logo(enable_colored_logo=True))

    # Handling arguments (command-line use)
    parser = argparse.ArgumentParser()
    # Target Options
    parser.add_argument("-u", "--url",
                        dest="url",
                        help="Check a single URL.",
                        action='store')
    parser.add_argument("-l", "--list",
                        dest="usedlist",
                        help="Check a list of URLs.",
                        action='store')
    parser.add_argument("--stdin",
                        dest="use_stdin",
                        help="Checks URLs from STDIN input.",
                        action='store_true')
    # Testing Options
    parser.add_argument("-level", "--level",
                        dest="testing_level",
                        help="Set testing level [0-4]\
                        (Default: 4).",
                        action='store',
                        default=4)
    parser.add_argument("--dvcs-test",
                        dest="dvcs_test",
                        help="Performs only testing for DVCS,\
                        which is available by default on Level 4.",
                        action='store_true')
    # Artifacts Detection Options
    parser.add_argument("-vsc", "--valid-status-codes",
                        dest="valid_status_codes",
                        help="Specify valid status codes\
                        for checks, separated by commas.\
                        (Default: 200).",
                        action='store',
                        default=[200])
    parser.add_argument("-isc", "--invalid-status-codes",
                        dest="invalid_status_codes",
                        help="Specify invalid status codes\
                        for checks, separated by commas. \
                        (Default: 403,404)",
                        action='store',
                        default=[403, 404])
    parser.add_argument("-icl", "--invalid-content-length",
                        dest="invalid_content_length",
                        help="Manually specify the invalid\
                        Content-Length, instead of performing\
                        this check automatically.",
                        action='store')
    parser.add_argument("--content-length-range",
                        dest="content_length_range",
                        help="Manually specify the Content-Length\
                        range for invalid pages. (Default: 50)",
                        action='store',
                        default=50)
    parser.add_argument("--verify-file-availability",
                        dest="verify_file_availability",
                        help="Method to verify the availability\
                        of the file. (Options: status_code,\
                        content_length,both) (Default: both)",
                        action='store',
                        default='both')
    parser.add_argument("-xsc", "--exclude-status-codes",
                        dest="exclude_status_codes",
                        help="Specify status codes to exclude,\
                        separated by commas.",
                        action='store',
                        default=[])
    # Output-Related Options
    parser.add_argument("-o", "--output",
                        dest='output_file',
                        help="Save identified URLs into a file.",
                        action='store')
    parser.add_argument("--verbose-output",
                        dest='verbose_output_file',
                        help="Save identified URLs, with \
                        status-codes and content-length into a file.",
                        action='store')
    # Request-Related Options
    parser.add_argument("-ua", "--user-agent",
                        dest='user_agent',
                        help="HTTP User-Agent header value.",
                        action='store')
    parser.add_argument("-ra", "--random-agent", "--random-agents",
                        dest='random_agent',
                        help="Use random User-Agents.",
                        action='store_true')
    parser.add_argument("--cookie",
                        dest='cookie',
                        help="HTTP Cookie header value.",
                        action='store')
    parser.add_argument("--host",
                        dest='host',
                        help="HTTP Host header value.",
                        action='store')
    parser.add_argument("--headers",
                        dest='headers',
                        help="Extra headers\
                        (e.g. \"Accept-Language: fr\\n\
                        ETag: 123\")",
                        action='store')
    parser.add_argument("--proxy",
                        dest='proxy',
                        help="Use a proxy\
                        on testing.",
                        action='store')
    parser.add_argument("--proxy-cred",
                        dest='proxy_cred',
                        help="Proxy authentication credentials\
                        (name:password)",
                        action='store')
    parser.add_argument("--timeout",
                        dest='timeout',
                        help="HTTP Request timeout by seconds.\
                        (Default: 5)",
                        action='store',
                        default=5)
    # Other Options
    parser.add_argument("--no-text",
                        dest='notext',
                        help="Prints and writes a clean output\
                        with only results.",
                        action='store_true')
    parser.add_argument("--api",
                        dest='api',
                        help="Showing findings in a form of list,\
                        suitable for APIs.",
                        action="store_true")
    parser.add_argument("-v", "--verbose",
                        dest='verbosity',
                        help="Enable verbosity.",
                        action='store_true')
    parser.add_argument("--debug",
                        dest='enable_debug',
                        help="Enable debugging.",
                        action='store_true',
                        default=False)
    parser.add_argument("-V", "--version",
                        dest='show_version',
                        help="Show current vesion and exit.",
                        action='store_true')

    args = parser.parse_args()

    # Handling input from argparse (Command-line use).
    url = args.url if args.url else None
    usedlist = args.usedlist if args.usedlist else None
    use_stdin = args.use_stdin if args.use_stdin else None
    testing_level = args.testing_level if args.testing_level else None
    dvcs_test = args.dvcs_test if args.dvcs_test else None

    if args.valid_status_codes:
        valid_status_codes = args.valid_status_codes
    else:
        valid_status_codes = None
    if args.invalid_status_codes:
        invalid_status_codes = args.invalid_status_codes
    else:
        invalid_status_codes = None
    if args.invalid_content_length:
        invalid_content_length = args.invalid_content_length
    else:
        invalid_content_length = None
    if args.content_length_range:
        content_length_range = args.content_length_range
    else:
        content_length_range = None
    if args.verify_file_availability:
        verify_file_availability = args.verify_file_availability
    else:
        verify_file_availability = None
    if args.exclude_status_codes:
        exclude_status_codes = args.exclude_status_codes
    else:
        exclude_status_codes = None
    # Used if-statements on multiple lines to not break PEP8-E501
    output_file = args.output_file if args.output_file else None
    if args.verbose_output_file:
        verbose_output_file = args.verbose_output_file
    else:
        verbose_output_file = None
    user_agent = args.user_agent if args.user_agent else None
    random_agent = args.random_agent if args.random_agent else None
    cookie = args.cookie if args.cookie else None
    host = args.host if args.host else None
    headers = args.headers if args.headers else None
    proxy = args.proxy if args.proxy else None
    proxy_cred = args.proxy_cred if args.proxy_cred else None
    timeout = args.timeout if args.timeout else None
    notext = args.notext if args.notext else None
    api = args.api if args.api else None
    verbosity = args.verbosity if args.verbosity else None
    enable_debug = args.enable_debug if args.enable_debug else False
    show_version = args.show_version if args.show_version else None

if (__name__ != '__main__'):
    # Arguments if called outside __main__
    url = None
    usedlist = None
    testing_level = 4
    dvcs_test = False
    valid_status_codes = [200]
    invalid_status_codes = [403, 404]
    content_length_range = 50
    verify_file_availability = 'both'
    exclude_status_codes = []
    output_file = None
    verbose_output_file = None
    user_agent = None
    random_agent = None
    cookie = None
    host = None
    headers = None
    proxy = None
    proxy_cred = None
    timeout = 5
    notext = None
    api = True
    verbosity = False
    enable_debug = False
    show_version = None


def Exception_Handler(message, exception):
    global enable_debug
    global api, notext
    if ((api is True) or (notext is True) or (__name__ != '__main__')):
        return(1)
        # showing exception that  --debug is not used
        # or when used as a module or --api or
        # --notext is used.
    if enable_debug is not True:
        return(2)
    exception = str(exception)
    message = str(message)
    print("%sError: %s :: %s%s" % (tcolor.red,
                                   message,
                                   exception,
                                   tcolor.endcolor))
    return(0)


class Request_Handler():
    """
    Responsible for handling URLs and perfoming requests.
    """
    def __init__(self):
        self.timeout = 5  # Default timeout.

    def UA_handler(self, use_random_agent=False):
        if use_random_agent is False:
            # BFAC DEFAULT UA
            chosen_agent = 'BFAC ' + str(version) + \
                ' (https://github.com/mazen160/bfac)'

        if use_random_agent is True:
            # List of random User-Agents.
            agents = [
                "Mozilla/5.0 (Windows NT 6.1; WOW64; rv:51.0) " +
                "Gecko/20100101 Firefox/51.0",
                "Mozilla/5.0 (Windows NT 10.0; WOW64; rv:51.0)" +
                " Gecko/20100101 Firefox/51.0",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
                "AppleWebKit/537.36 (KHTML, like Gecko) " +
                "Chrome/46.0.2486.0 Safari/537.36 Edge/13.10586",
                "Mozilla/5.0 (Windows NT 10.0; Win64; x64) " +
                "AppleWebKit/537.36 (KHTML, like Gecko) " +
                "Chrome/56.0.2924.87 Safari/537.36",
                "Mozilla/5.0 (Windows NT 6.1; WOW64; " +
                "Trident/7.0; rv:11.0) like Gecko",
                "Mozilla/5.0 (Macintosh; Intel Mac OS " +
                "X 10_12_2) AppleWebKit/602.3.12 (KHTML, " +
                "like Gecko) Version/10.0.2 Safari/602.3.12",
                "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; " +
                "rv:51.0) Gecko/20100101 Firefox/51.0",
                "Mozilla/5.0 (iPhone; CPU iPhone OS 10_2_1 " +
                "like Mac OS X) AppleWebKit/602.4.6 (KHTML, " +
                "like Gecko) Version/10.0 Mobile/14D27" +
                " Safari/602.1",
                "Mozilla/5.0 (Linux; Android 6.0.1; " +
                "Nexus 6P Build/MTC19X) AppleWebKit/537.36 " +
                "(KHTML, like Gecko) Chrome/56.0.2924.87 " +
                "Mobile Safari/537.36",
                "Mozilla/5.0 (Linux; Android 4.4.4; Nexus 5 " +
                "Build/KTU84P) AppleWebKit/537.36 (KHTML, " +
                "like Gecko) Chrome/56.0.2924.87" +
                "Mobile Safari/537.36",
                "Mozilla/5.0 (compatible; Googlebot/2.1; " +
                "+http://www.google.com/bot.html)"
            ]

            chosen_agent = random.choice(agents)
        return(chosen_agent)

    def requester(self, link, proxy=None, proxy_cred=None,
                  custom_user_agent=None, cookie=None,
                  host_header=None, http_headers=None,
                  random_user_agent=False, timeout=None,
                  api=False, notext=False):

        global verbosity
        if timeout is None:
            timeout = self.timeout  # Use default timeout.

        try:
            user_agent = None
            if random_user_agent is True:
                user_agent = self.UA_handler(use_random_agent=True)
            if custom_user_agent is not None:
                user_agent = custom_user_agent
            if ((random_user_agent is not True) and
                    (custom_user_agent is None)):
                # Use BFAC default UA.
                user_agent = self.UA_handler(use_random_agent=False)
            if user_agent is None:  # If somehow passed the above.
                user_agent = self.UA_handler(use_random_agent=False)

            headers = {'User-Agent': user_agent, 'Accept': '*/*'}

            if cookie is not None:
                cookie_dict = {'Cookie': str(cookie)}
                headers.update(cookie_dict)

            if host_header is not None:
                host_dict = {'Host': str(host_header)}
                headers.update(host_dict)

            if http_headers is not None:
                extra_headers_handler = http_headers.replace('\r', '')
                headers_list = extra_headers_handler.split('\\n')
                for _ in headers_list:
                    if (len(_.split(':')) != 2):
                        pass
                    else:
                        header = _.split(':')[0]
                        header_value = _.split(':')[1]

                        header_value = list(header_value)
                        # Need to check if first element is \x20
                        # because of an error shown when requesting.
                        if (header_value[0] == ' '):
                            header_value[0] = ''
                        header_value = ''.join(header_value)

                        add_header = {str(header): str(header_value)}
                        headers.update(add_header)

            if proxy is not None:
                proxy = str(proxy)
                proxy_scheme_original = proxy.split(':')[0].lower()
                # requests module is buggy when it comes to proxying.
                # We will use the default proxy_scheme as "http"
                # for http and socks4/5. This is the only easy way.
                proxy_scheme = 'http'

                if (proxy_cred is not None):
                    username = str(str(proxy_cred).split(':')[0])
                    password = str(str(proxy_cred).split(':')[1])
                    replace_original_start_with = (
                        str(proxy_scheme_original) +
                        '://' + str(username) +
                        ':' +
                        str(password) +
                        str('@'))
                    proxy_url = proxy.replace(
                        str(proxy_scheme_original) + '://',
                        replace_original_start_with)
                else:
                    proxy_url = str(proxy)
                proxy_dict = {str(proxy_scheme): str(proxy_url)}

                # Establishing request with proxy.
                req = requests.get(link,
                                   headers=headers,
                                   verify=False,
                                   allow_redirects=False,
                                   timeout=int(timeout),
                                   proxies=proxy_dict)

            if proxy is None:
                # Establishing request without proxy.
                req = requests.get(link,
                                   headers=headers,
                                   verify=False,
                                   allow_redirects=False,
                                   timeout=int(timeout))

            request_response_code = req.status_code
            request_response_content_length = len(req.content)
            return(request_response_code,
                   request_response_content_length)

        except requests.exceptions.SSLError as e:
            Exception_Handler('SSL Error at ' + str(link),
                              str(e))
            return(None, None)
        except requests.exceptions.ConnectionError as e:
            Exception_Handler('Connection Error at ' + str(link),
                              str(e))
            return(None, None)
        except requests.exceptions.MissingSchema as e:
            Exception_Handler('Error: Invalid URL' +
                              ' - Missing Schema at ' + str(link),
                              str(e))
            return(None, None)
        except requests.exceptions.InvalidSchema as e:
            Exception_Handler('Error: Invalid URL' +
                              ' - Invalid Schema at ' + str(link),
                              str(e))
            return(None, None)
        except requests.exceptions.InvalidURL as e:
            Exception_Handler('Error: Invalid URL at ' + str(link),
                              str(e))
            return(None, None)
        except requests.exceptions.ReadTimeout as e:
            Exception_Handler('Error: Connection Timeout' +
                              ' - Invalid Schema at ' + str(link),
                              str(e))
            return(None, None)


class URL_Work():
    """
    This class is responsible for handling URLs for testing.
    """

    def url_clean(self, url):
        """
        Cleans-up a URL.
        """
        url = url.split('?')[0]
        url = url.replace('#', '%23')
        url = url.replace(' ', '%20')
        return(url)

    def url_handler(self, url):
        """
        Parses a URL, and returns output of URL structure.
        """
        try:
            # Assuming URL is: http://example.com/uploads/test.php

            # Cleaning url
            url = self.url_clean(url)

            # Sheme: http
            default_protocol = 'http'
            if ('://' not in url):
                url = str(default_protocol) + str('://') + str(url)
            scheme = urlparse.urlparse(url).scheme

            # Domain: example.com
            domain = urlparse.urlparse(url).netloc

            # Site: http://example.com
            site = scheme + '://' + domain

            # FilePath: /uploads/test.php
            file_path = urlparse.urlparse(url).path
            if (file_path == ''):
                file_path = '/'

            # Filename: test.php
            try:
                filename = url.split('/')[-1]
            except IndexError:
                filename = ''

            # File Dir: /uploads/
            file_dir = file_path.rstrip(filename)
            if (file_dir == ''):
                file_dir = '/'

            # FullPath: http://example.com/uploads/
            full_path = site + file_dir

            # File Extension: php
            try:
                filename_ext = filename.split('.')
                filename_ext.pop(0)
                filename_ext = '.'.join(filename_ext)
            except IndexError:
                filename_ext = ''

            # File without Extension: test
            try:
                filename_without_ext = filename.split('.')[0]
            except IndexError:
                filename_without_ext = ''
        except IndexError:
            pass

        return(scheme, domain, site, file_path, filename, file_dir,
               full_path, filename_ext, filename_without_ext)


def Generate_BFA_URLs(url,
                      testing_level=4,
                      dvcs_test=False):
    """
    Generates BFA testing URLs.
    Returns a list of BFA testing URLs of given URL.
    """

    (scheme, domain, site, file_path, filename,
     file_dir, full_path, filename_ext,
     filename_without_ext) = URL_Work().url_handler(url)

    backup_testing_level0 = [
        site + file_path + '~',
        site + file_path + '%23',
        site + file_path + '.save',
        site + file_path + '.swp',
        site + file_path + '.swo',
        full_path + '%23' + filename + '%23',
        site + file_path + '.bak'
    ]

    backup_testing_level1 = [
        site + file_path + '_',
        site + file_path + '_bak',
        site + file_path + '-bak',
        site + file_path + '.bk',
        site + file_path + '.bkp',
        full_path + filename + '.bac',
        site + file_path + '.old',
        site + file_path + '_old',
        site + file_path + '.copy',
        site + file_path + '.original',
        site + file_path + '.orig',
        site + file_path + '.org',
        site + file_path + '.txt',
        site + file_path + '.default',
        full_path + filename + '.tpl',
        full_path + filename + '.tmp',
        full_path + filename + '.temp',
        full_path + '.' + filename + ".swp",
        full_path + '.' + filename + ".swo",
        full_path + '_' + filename + '.swp',
        full_path + '_' + filename + '.swo',
        full_path + filename + '.sav',
        full_path + filename + '.conf',
        full_path + filename_without_ext +
        '%20%28copy%29.' + filename_ext,
        full_path + 'Copy%20of%20' + filename,
        full_path + 'copy%20of%20' + filename,
        full_path + 'Copy_' + filename,
        full_path + 'Copy%20' + filename,
        full_path + 'Copy_of_' + filename,
        full_path + 'Copy_(1)_of_' + filename,
        full_path + 'Copy_(2)_of_' + filename,
        full_path + filename_without_ext +
        '%20-%20Copy.' + filename_ext,
        full_path + filename_without_ext + '%20copy.' + filename_ext
    ]

    backup_testing_level2 = [
        full_path + filename_without_ext + '.txt',
        full_path + filename_without_ext + '.bak',
        full_path + filename_without_ext + '.bak1',
        full_path + filename_without_ext + '.bakup',
        full_path + filename_without_ext + '.bakup1',
        full_path + filename_without_ext + '.bkp',
        full_path + filename_without_ext + '.save',
        full_path + filename_without_ext + '.old',
        full_path + filename_without_ext + '.orig',
        full_path + filename_without_ext + '.original',
        full_path + filename_without_ext + '.sql',
        site + file_path + '%00',
        site + file_path + '%01',
        full_path + '~' + filename,
        full_path + filename_without_ext + '.tpl',
        full_path + filename_without_ext + '.tmp',
        full_path + filename_without_ext + '.temp',
        full_path + filename + '.saved',
        full_path + filename + '.back',
        full_path + filename + '.bck',
        full_path + filename + '.bakup',
        full_path + filename_without_ext + '.saved',
        full_path + filename_without_ext + '.back',
        full_path + filename_without_ext + '.bck',
        full_path + filename_without_ext + '.bakup',
        full_path + '_' + filename,
        full_path + '%20' + filename,
        full_path + filename + '.nsx',
        full_path + filename + '.cs',
        full_path + filename + '.csproj',
        full_path + filename + '.vb',
        full_path + filename + '.0',
        full_path + filename + '.1',
        full_path + filename + '.2',
        full_path + filename + '.arc',
        full_path + filename + '.inc',
        full_path + filename + '.lst',
        full_path + '.~lock.' + filename + '%23',
        full_path + '.~' + filename,
        full_path + '~%24' + filename
    ]

    backup_testing_level3 = [
        site + file_path + '.tar',
        site + file_path + '.rar',
        site + file_path + '.zip',
        full_path + '~' + filename_without_ext + '.tmp',
        site + file_path + '.tar.gz',
        full_path + 'backup-' + filename,
        full_path + filename_without_ext + '-backup.' + filename_ext,
        full_path + filename_without_ext + '-bkp.' + filename_ext,
        full_path + filename_without_ext + '.tar',
        full_path + filename_without_ext + '.rar',
        full_path + filename_without_ext + '.zip',
        full_path + filename_without_ext + '.tar.gz',
        full_path + filename_without_ext + '.sql.gz',
        full_path + filename_without_ext + '.bak.sql',
        full_path + filename_without_ext + '.bak.sql.gz',
        full_path + filename_without_ext + '.bak.sql.bz2',
        full_path + filename_without_ext + '.bak.sql.tar.gz'
    ]

    backup_testing_level4 = [
        site + '/.git/HEAD',
        full_path + '.git/HEAD',
        site + '/.git/index',
        full_path + '.git/index',
        site + '/.git/config',
        full_path + '.git/config',
        site + '/.gitignore',
        full_path + '.gitignore',
        site + '/.git-credentials',
        full_path + '.git-credentials',
        site + '/.bzr/README',
        full_path + '.bzr/README',
        site + '/.bzr/checkout/dirstate',
        full_path + '.bzr/checkout/dirstate',
        site + '/.hg/requires',
        full_path + '.hg/requires',
        site + '/.hg/store/fncache',
        full_path + '.hg/store/fncache',
        site + '/.svn/entries',
        full_path + '.svn/entries',
        site + '/.svn/all-wcprops',
        full_path + '.svn/all-wcprops',
        site + '/.svnignore',
        full_path + '.svnignore',
        site + '/CVS/Entries',
        full_path + 'CVS/Entries',
        site + '/.cvsignore',
        full_path + '.cvsignore',
        site + '/.idea/misc.xml',
        full_path + '.idea/misc.xml',
        site + '/.idea/workspace.xml',
        full_path + '.idea/workspace.xml',
        site + '/.DS_Store',
        full_path + '.DS_Store',
        site + '/composer.lock',
        full_path + 'composer.lock'
    ]

    testing_level = str(testing_level)

    available_levels = ['0', '1', '2', '3', '4']
    # Check is requested testing_level is within available levels.
    # If not within available levels, choose highest level.
    if (testing_level not in available_levels):
        testing_level = '4'

    if (testing_level == '0'):
        backup_testing_checks = backup_testing_level0
    if (testing_level == '1'):
        backup_testing_checks = backup_testing_level0 + \
            backup_testing_level1
    if (testing_level == '2'):
        backup_testing_checks = backup_testing_level0 + \
            backup_testing_level1 + \
            backup_testing_level2
    if (testing_level == '3'):
        backup_testing_checks = backup_testing_level0 + \
            backup_testing_level1 + \
            backup_testing_level2 + \
            backup_testing_level3
    if (testing_level == '4'):
        backup_testing_checks = backup_testing_level0 + \
            backup_testing_level1 + \
            backup_testing_level2 + \
            backup_testing_level3 + \
            backup_testing_level4
    if (dvcs_test is True):
        backup_testing_checks = backup_testing_level4

    backup_testing_checks = list(set(backup_testing_checks))
    backup_testing_checks = random.sample(backup_testing_checks,
                                          len(
                                              backup_testing_checks
                                          )
                                          )
    return(backup_testing_checks)


class Verify_Response():
    """
    This class checks and verifies results of requested URLs,
     and verify file(s) existence.
    """

    def __init__(self):
        pass

    def Verify_via_Status_Code(self,
                               response_status_code,
                               valid_status_codes=[200],
                               invalid_status_codes=[403, 404],
                               exclude_status_codes=[]):
        """
        Performs checks on HTTP response status codes.
        * Returns True is the response is valid, and file seems
          to exists
        * Returns False is the file does not seem to exist.
        * Returns int > 0: if there was an issue
          in valid_status_codes orinvalid_status_codes.
        """

        # Validating
        result = False
        if (response_status_code is None):
            result = False

        if exclude_status_codes is None:
            exclude_status_codes = []

        for valid_status_code in valid_status_codes:
            if (str(response_status_code) == str(valid_status_code)):
                result = True
                break
            else:
                result = False
        for invalid_status_code in invalid_status_codes:
            if (str(response_status_code) == str(invalid_status_code)):
                result = False
                break

        for exclude_status_code in exclude_status_codes:
            if (str(response_status_code) == str(exclude_status_code)):
                result = False
                break
        return(result)

    def Check_If_Exists_In_Excluded_Status_Codes(
            self,
            response_code,
            exclude_status_codes=[]):

        result = False
        if exclude_status_codes is None:
            exclude_status_codes = []
        for exclude_status_code in exclude_status_codes:
            if (str(exclude_status_code) == str(response_code)):
                result = True
                break
            else:
                result = False
        return(result)

    def Initial_Request(self,
                        link,
                        force_initial_content_length=None,
                        forced_initial_content_length=None,
                        proxy=None,
                        proxy_cred=None,
                        custom_user_agent=None,
                        cookie=None,
                        host_header=None,
                        http_headers=None,
                        random_user_agent=False,
                        timeout=None,
                        api=False,
                        notext=False):
        """
        Performs initial request and gives a baseline, based on it,
        the detection for content-length will be done.
        if force_initial_content_length
        is set, it will force their values as a result.
        """

        if ((force_initial_content_length is True) and
           (forced_initial_content_length is not None)):

            expected_status_code = 200
            return(forced_initial_content_length)

        # Obtain site and file_dir via URL_Work().url_handler()
        site = URL_Work().url_handler(link)[2]
        file_dir = URL_Work().url_handler(link)[5]

        random_ascii_charset = 'abcdefghijklmnopqrstuvwxyz0123456789'
        random_value = \
            ''.join(random.choice(random_ascii_charset)
                    for _ in range(5))
        random_value_ext = \
            ''.join(random.choice(random_ascii_charset)
                    for _ in range(3))

        link = site + file_dir + random_value + '.' + random_value_ext

        # Using Requester API
        try:
            resp = Request_Handler().requester(
                link,
                proxy=proxy,
                proxy_cred=proxy_cred,
                custom_user_agent=custom_user_agent,
                cookie=cookie,
                host_header=host_header,
                http_headers=http_headers,
                random_user_agent=random_user_agent,
                timeout=timeout,
                api=api,
                notext=notext)

            initial_status_code = resp[0]
            initial_content_length = resp[1]
        except:
            initial_status_code, initial_content_length = 0, 0

            if ((initial_status_code is None) or
               (initial_content_length is None)):
                initial_status_code = 0
                initial_content_length = 0

        return(initial_status_code, initial_content_length)

    def Calculate_Valid_Content_Length(self,
                                       content_length,
                                       CL_range=50):
        """
        Calculates expected valid content-lengths,
        based off the initial conducted request.
        Returns min and max.
        """

        if (content_length is None):
            return(0, 0)
        content_length_range = int(CL_range)
        initial_content_length_min = \
            content_length - content_length_range
        initial_content_length_max = \
            content_length_range + content_length

        if (initial_content_length_max < 0):
            initial_content_length_max = 0
        if (initial_content_length_min < 0):
            initial_content_length_min = 0

        return(initial_content_length_min, initial_content_length_max)

    def Verify_via_Content_Length(self,
                                  content_length,
                                  initial_content_length_min,
                                  initial_content_length_max):
        """
        Verifies if the file exists by checking the content-length.
        * Returns True if the file exists.
        * Returns False if the file does not exist.
        * Returns int > 0 if there is any sort of exception.
        """
        content_length_test = True
        if (content_length is None):
            content_length_test = False
            return(content_length_test)
        if ((initial_content_length_min is None) or
           (initial_content_length_max is None)):
                return(3)
        initial_content_length_max = int(initial_content_length_max)
        for num in range(initial_content_length_min,
                         initial_content_length_max + 1):
            if (num == content_length):
                content_length_test = False
        return(content_length_test)

    def Request_Check(self,
                      use_content_length_checks=True,
                      use_status_code_checks=True,
                      content_length=None,
                      initial_content_length_min=None,
                      initial_content_length_max=None,
                      content_length_range=50,
                      response_status_code=None,
                      valid_status_codes=[200],
                      invalid_status_codes=[403, 404],
                      exclude_status_codes=[]):
        """
        Checks whether a file exists based on the response.
        Returns True if the file exists.
        Returns False if the file does not exist.
        Returns int > 1 if an occur.
        """
        Request_Check_Status = False

        # Check content-length test
        CL_result = False  # Initializing variable
        if (use_content_length_checks is True):
            if ((content_length is None) and
                (initial_content_length_min is None) and
               (initial_content_length_max is None)):
                return(4)  # Invalid input.

        if (use_content_length_checks is True):
            CL_result = self.Verify_via_Content_Length(
                content_length,
                initial_content_length_min,
                initial_content_length_max)
        else:
            CL_result = False

        # Check status-code test
        # There is no need to verify the input.
        # It's already being verified well in Verify_via_Status_Code.
        SC_result = False  # Initializing variable
        if (use_status_code_checks is True):
            SC_result = self.Verify_via_Status_Code(
                response_status_code,
                valid_status_codes=valid_status_codes,
                invalid_status_codes=invalid_status_codes,
                exclude_status_codes=exclude_status_codes)
        # Checking and returning result.

        if ((SC_result is True) or (CL_result is True)):
            Request_Check_Status = True
        return(Request_Check_Status)


def Request_and_Verify_Response(url,
                                use_content_length_checks=True,
                                use_status_code_checks=True,
                                valid_status_codes=[200],
                                invalid_status_codes=[403, 404],
                                exclude_status_codes=[],
                                initial_content_length_min=None,
                                initial_content_length_max=None,
                                force_initial_content_length=None,
                                proxy=None,
                                proxy_cred=None,
                                custom_user_agent=None,
                                cookie=None,
                                host_header=None,
                                http_headers=None,
                                random_user_agent=False,
                                timeout=None,
                                api=False,
                                notext=False):
    """
    This function uses the Request_Handler()
    and Verify_via_Status_Code() classes to test a URL.
    and returns if the file exists or not.
    * Returns True: if the file exists.
    * Returns False: if the file does not exist.
    Note: This function is intended for a single URL;
          It only shows plain results based for a single URL
          and determines whether a file exists on the server or not.
    """
    resp = Request_Handler().requester(
        url,
        proxy=proxy,
        proxy_cred=proxy_cred,
        custom_user_agent=custom_user_agent,
        cookie=cookie,
        host_header=host_header,
        http_headers=http_headers,
        random_user_agent=random_user_agent,
        timeout=timeout,
        api=api,
        notext=notext)

    File_Exists = Verify_Response().Request_Check(
        use_content_length_checks=use_content_length_checks,
        use_status_code_checks=use_status_code_checks,
        content_length=resp[1],
        initial_content_length_min=initial_content_length_min,
        initial_content_length_max=initial_content_length_max,
        content_length_range=content_length_range,
        response_status_code=resp[0],
        valid_status_codes=valid_status_codes,
        invalid_status_codes=invalid_status_codes,
        exclude_status_codes=exclude_status_codes)

    # Exclude file from findings if it contains an excluded
    # status-code.
    x_SC = Verify_Response().Check_If_Exists_In_Excluded_Status_Codes(
        resp[0],
        exclude_status_codes=exclude_status_codes)

    if x_SC is True:
        File_Exists = False

    return(File_Exists, resp)


"""
These variables save the findings list and the tested URLs.
"""
testedjar = []
findings_list = []


class Output_Results():
    """
    Responsible for saving results in an external file.
    """
    def __init__(self):
        pass

    def Save_in_TXT_simple(self, url, txt_file, newline=True):
        """
        Save results in plain text file.
        Save only URLs.
        """
        try:
            output = open(txt_file, 'a')
            output.write(url)
            if newline is True:
                output.write('\n')
            output.close()
        except IOError as e:
            Exception_Handler('Error: IOError', str(e))
            if ((api is not True) and (notext is not True)):
                print(tcolor.red + '[!] Error: There was an error ' +
                      'writing the output.' + tcolor.endcolor)
            print('\nExiting...')
            exit(1)
        except TypeError as e:
            Exception_Handler('Error: TypeError', str(e))
            if ((api is not True) and (notext is not True)):
                print(tcolor.red + '[!] Error: There was an error ' +
                      'writing the output.' + tcolor.endcolor)
            print('\nExiting...')
            exit(1)
        return(0)

    def Save_in_TXT_verbose(self, url, status_code,
                            content_length, txt_file, newline=True):
        """
        Save results in plain text file.
        Save  URLs, Status-Code, Content-Length.
        """

        try:
            output = open(txt_file, 'a')
            output_data = '[URL]: %s' % (str(url)) + \
                          ' | ' + \
                          '[Status-Code]: %s' % (str(status_code)) + \
                          ' | ' + \
                          '[Content-Length]: ' + \
                          '%s' % (str(content_length))

            output.write(output_data)
            if newline is True:
                output.write('\n')
            output.close()
        except IOError as e:
            Exception_Handler('Error: IOError', str(e))
            if ((api is not True) and (notext is not True)):
                print(tcolor.red + '[!] Error: There was an error ' +
                      'writing the output.' + tcolor.endcolor)
            print('\nExiting...')
            exit(1)
        except TypeError as e:
            Exception_Handler('Error: TypeError', str(e))
            if ((api is not True) and (notext is not True)):
                print(tcolor.red + '[!] Error: There was an error ' +
                      'writing the output.' + tcolor.endcolor)
            print('\nExiting...')
            exit(1)
        return(0)


class ConsoleOutput():

    def Verbose_Testing_Message(self,
                                url,
                                response_status_code,
                                content_length):
        if (__name__ != '__main__'):
            return(5)

        print("[*] Checking [%s] " % (str(url)) +
              "(Response-Code: %s" % (str(response_status_code)) +
              " | " +
              "Content-Length: %s)" % (str(content_length)))

    def Found_Message(self,
                      url,
                      response_status_code,
                      content_length):
        if (__name__ != '__main__'):
            return(6)

        print("%s[$] Discovered: -> {%s} " % (tcolor.green, str(url)) +
              "(Response-Code: %s" % (str(response_status_code)) +
              " | " +
              "Content-Length: %s)%s" % (str(content_length),
                                         tcolor.endcolor))

    def Message_with_all_Findings(self,
                                  findings_list):
        if (__name__ != '__main__'):
            return(7)

        print('\n\n')
        print('%s   [^()^] Findings:-%s' % (tcolor.light_blue,
                                            tcolor.endcolor))
        if (len(findings_list) == 0):
            print('[%] No BFA was identified.')
            return(0)

        for _ in findings_list:
            print(str(_))
        return(0)


def Test_URL(url,
             dvcs_test=False,
             testing_level=4,
             use_content_length_checks=True,
             use_status_code_checks=True,
             valid_status_codes=[200],
             invalid_status_codes=[403, 404],
             exclude_status_codes=[],
             content_length_range=50,
             force_initial_content_length=None,
             proxy=None,
             proxy_cred=None,
             custom_user_agent=None,
             cookie=None,
             host_header=None,
             http_headers=None,
             random_user_agent=False,
             timeout=None,
             api=False,
             notext=False,
             verbosity=False):
    """
    This function performs BFA testing on a single URL.
    """

    if (len(url) == 0):
        return(8)
    global testedjar, findings_list
    global output_file, verbose_output_file

    Generated_URLS = Generate_BFA_URLs(
        url,
        testing_level=testing_level,
        dvcs_test=dvcs_test)
    Done_init_req = False
    Continue_Test = True

    if ((api is not True) and
       (notext is not True) and
       (__name__ == '__main__')):
        print('[#] Testing URL:-> %s' % (url))

    if ((use_content_length_checks is True) and
       (force_initial_content_length is True)):
        content_length_range = forced_initial_content_length

    if ((use_content_length_checks is True) and
       (force_initial_content_length is not True)):
        Force_init_CL = force_initial_content_length

        init_req = Verify_Response().Initial_Request(
            url,
            force_initial_content_length=Force_init_CL,
            proxy=proxy,
            proxy_cred=proxy_cred,
            custom_user_agent=custom_user_agent,
            cookie=cookie,
            host_header=host_header,
            http_headers=http_headers,
            random_user_agent=random_user_agent,
            timeout=timeout,
            api=api,
            notext=notext)
        Done_init_req = True

        CL_calc = Verify_Response().Calculate_Valid_Content_Length(
            init_req[1],
            content_length_range)
    else:
        CL_calc = [0, 0]

    if (use_content_length_checks is False):
        Use_CL_checks = use_content_length_checks
        # Done the above line to not break PEP8-E501
        CL_calc = [0, 0]
    else:
        Use_CL_checks = None

    if (Done_init_req is False):
        init_req = Verify_Response().Initial_Request(
            url,
            force_initial_content_length=force_initial_content_length,
            proxy=proxy,
            proxy_cred=proxy_cred,
            custom_user_agent=custom_user_agent,
            cookie=cookie,
            host_header=host_header,
            http_headers=http_headers,
            random_user_agent=random_user_agent,
            timeout=timeout,
            api=api,
            notext=notext)

    if (None in init_req) or (0 in init_req):
        Continue_Test = False
        if (Continue_Test is False):
            if ((api is not True) and
               (notext is not True) and
               (__name__ == '__main__')):
                print('[!] Host ' +
                      '[%s]' % (URL_Work().url_handler(url)[1]) +
                      ' does not seem to respond as expected.')
                print('Skipping...')
            return(9)

    for url in Generated_URLS:
        if url in testedjar:
            continue  # This means that the URL is already tested.
        result = Request_and_Verify_Response(
            url,
            use_content_length_checks=use_content_length_checks,
            use_status_code_checks=use_status_code_checks,
            valid_status_codes=valid_status_codes,
            invalid_status_codes=invalid_status_codes,
            exclude_status_codes=exclude_status_codes,
            initial_content_length_min=CL_calc[0],
            initial_content_length_max=CL_calc[1],
            force_initial_content_length=force_initial_content_length,
            proxy=proxy,
            proxy_cred=proxy_cred,
            custom_user_agent=custom_user_agent,
            cookie=cookie,
            host_header=host_header,
            http_headers=http_headers,
            random_user_agent=random_user_agent,
            timeout=timeout,
            api=api,
            notext=notext)

        if ((api is not True) and (notext is not True) and
           (verbosity is True)):
            ConsoleOutput().Verbose_Testing_Message(url,
                                                    result[1][0],
                                                    result[1][1])
        testedjar.append(url)
        if (result[0] is True):
            if result[0] not in findings_list:
                findings_list.append(url)
            if (api is not True) and (notext is not True):
                ConsoleOutput().Found_Message(url,
                                              result[1][0],
                                              result[1][1])
            # External output
            if (output_file):
                Output_Results().Save_in_TXT_simple(url,
                                                    output_file)
            if (verbose_output_file):
                Output_Results().Save_in_TXT_verbose(
                    url,
                    result[1][0],
                    result[1][1],
                    verbose_output_file)

            if (api is True):
                pass  # Nothing will be printed.
            if (notext is True):
                print(url)  # Print the URL only.

    if (__name__ != '__main__'):
        return(findings_list)  # If BFAC called as a library.

    if (api is True):
        print(str(findings_list).replace('"', '\\"').replace("'", '"'))


# Prints version when requested (command-line use)
if (__name__ == '__main__'):
    if show_version:
        print(version)
        exit(0)

# Checking inputs when using via command-line.
if (__name__ == '__main__'):
    # Check if URL or List Input is used (command-line use)
    if ((url is None) and (usedlist is None) and (use_stdin is None)):
        e = '[!] Error: Either URL or List should be supplied.'
        print(tcolor.red + str(e) + tcolor.endcolor)
        print('\nExiting...')
        exit(1)

    # Check if both URL and List Input is used (command-line use)
    if (url is not None) and (usedlist is not None):
        e = '[!] Error: Both URL and List are supplied.'
        print(tcolor.red + str(e) + tcolor.endcolor)
        print('\nExiting...')
        exit(1)

    # Check if requested level is not within levels
    available_levels = ['0', '1', '2', '3', '4']
    if (str(testing_level) not in available_levels):
        e = '[!] Error: Chosen level is invalid.'
        print(tcolor.red + str(e) + tcolor.endcolor)
        print('\nExiting...')
        exit(1)

    # Check Verify File Availability input:
    verify_availability_options = ['status_code',
                                   'content_length',
                                   'both']
    if (verify_file_availability not in verify_availability_options):
        e = '[!]Error: Entered Verify File Availability option' + \
            ' is invalid.'
        print(tcolor.red + str(e) + tcolor.endcolor)
        print('\nExiting...')
        exit(1)

    if (api is True) and (notext is True):
        e = '[!] Error: Both --api and --notext are choosen.\n' + \
            'Only one of these options can be used.'
        print(tcolor.red + str(e) + tcolor.endcolor)
        print('\nExiting...')
        exit(1)

    # Initializing output file,
    # and checking if we have write access to file.
    if (output_file):
        try:
            open(output_file, 'a').close()
        except Exception as e:
            print(tcolor.red +
                  '[!] Error: There is an error in writing output.' +
                  tcolor.endcolor)
            Exception_Handler('Error: ', str(e))
            print('\nExiting...')
            exit(1)
    if (verbose_output_file):
        try:
            open(verbose_output_file, 'a').close()
        except Exception as e:
            print(tcolor.red +
                  '[!] Error: There is an error in writing output.' +
                  tcolor.endcolor)
            Exception_Handler('Error: ', str(e))
            print('\nExiting...')
            exit(1)

    # Parse status_codes
    if (isinstance(valid_status_codes, str) is True):
        valid_status_codes = valid_status_codes.replace(' ', '')
        valid_status_codes = valid_status_codes.split(', ')
    if (isinstance(invalid_status_codes, str) is True):
        invalid_status_codes = invalid_status_codes.replace(' ', '')
        invalid_status_codes = invalid_status_codes.split(',')
    if (isinstance(exclude_status_codes, str) is True):
        exclude_status_codes = exclude_status_codes.replace(' ', '')
        exclude_status_codes = exclude_status_codes.split(',')

    # Checking and validating status-codes inputs.
    if ((valid_status_codes is None) or (valid_status_codes == '')):
        valid_status_codes = []
    if ((invalid_status_codes is None) or
       (invalid_status_codes == '')):
        invalid_status_codes = []
    if ((exclude_status_codes is None) or
       (exclude_status_codes == '')):
        exclude_status_codes = []

    for valid_status_code in valid_status_codes:
        if valid_status_code in invalid_status_codes:
            e = "Error: Duplicate values in status codes."
            print(tcolor.red + str(e) + tcolor.endcolor)
            Exception_Handler(str(e),
                              "Valid status code "
                              "(%s)" % (valid_status_code) +
                              " exists" +
                              " on Invalid status codes" +
                              " list.")
            exit(1)
    for valid_status_code in valid_status_codes:
        if str.isdigit(str(valid_status_code)) is False:
            e = "Error: Invalid provided valid status code."
            print(tcolor.red + str(e) + tcolor.endcolor)
            Exception_Handler(str(e),
                              'Invalid provided valid' +
                              ' status code' +
                              '(%s).' % (valid_status_code))
            exit(1)
    for invalid_status_code in invalid_status_codes:
        if str.isdigit(str(invalid_status_code)) is False:
            e = 'Error: Invalid provided invalid status code.'
            print(tcolor.red + str(e) + tcolor.endcolor)
            Exception_Handler(str(e),
                              'Invalid provided invalid' +
                              ' status code ' +
                              '(%s).' % (invalid_status_code))
            exit(1)
    for exclude_status_code in exclude_status_codes:
        if str.isdigit(str(exclude_status_code)) is False:
            e = 'Error: Invalid provided excluded status code.'
            print(tcolor.red + str(e) + tcolor.endcolor)
            Exception_Handler(str(e),
                              'Invalid provided excluded' +
                              ' status code ' +
                              '(%s).' % (invalid_status_code))
            exit(1)

    if (verify_file_availability == 'both'):
        use_status_code_checks = True
        use_content_length_checks = True
    if (verify_file_availability == 'content_length'):
        use_status_code_checks = False
        use_content_length_checks = True
    if (verify_file_availability == 'status_code'):
        use_status_code_checks = True
        use_content_length_checks = False
    if (invalid_content_length is not None):
        force_initial_content_length = True
        forced_initial_content_length = invalid_content_length
    else:
        force_initial_content_length = False
        force_init_CL = force_initial_content_length

    if (url):
        try:
            Test_URL(
                url,
                dvcs_test=dvcs_test,
                testing_level=testing_level,
                use_content_length_checks=use_content_length_checks,
                use_status_code_checks=use_status_code_checks,
                valid_status_codes=valid_status_codes,
                invalid_status_codes=invalid_status_codes,
                exclude_status_codes=exclude_status_codes,
                content_length_range=content_length_range,
                force_initial_content_length=force_init_CL,
                proxy=proxy,
                proxy_cred=proxy_cred,
                custom_user_agent=user_agent,
                cookie=cookie,
                host_header=host,
                http_headers=headers,
                random_user_agent=random_agent,
                timeout=timeout,
                api=api,
                notext=notext,
                verbosity=verbosity)

            if ((api is not True) and (notext is not True)):
                ConsoleOutput().Message_with_all_Findings(findings_list)
                print(tcolor.purple +
                      '[*%*] Finished.' +
                      tcolor.endcolor)
        except KeyboardInterrupt:
            print('\nKeyboardInterrupt Detected.')
            print('\nExiting...')
            exit(1)

    if (usedlist or use_stdin):
        try:
            if usedlist:
                f_open = open(usedlist, 'r').readlines()
            if use_stdin:
                try:
                    f_open = stdin.readlines()
                except KeyboardInterrupt:
                    print('\nExiting...')
                    exit(0)
        except Exception as e:
            e = '[!] Error: Unable to use list [%s].' % (usedlist)
            if ((api is not True) and (notext is not True)):
                print(tcolor.red + str(e) + tcolor.endcolor)
                print('\nExiting...')
            exit(1)

        URLs_list = []
        for _ in f_open:
            _ = _.replace('\r', '').replace('\n', '')
            URLs_list.append(_)

        try:
            for url in URLs_list:
                Test_URL(
                    url,
                    dvcs_test=dvcs_test,
                    testing_level=testing_level,
                    use_content_length_checks=use_content_length_checks,
                    use_status_code_checks=use_status_code_checks,
                    valid_status_codes=valid_status_codes,
                    invalid_status_codes=invalid_status_codes,
                    exclude_status_codes=exclude_status_codes,
                    content_length_range=content_length_range,
                    force_initial_content_length=force_init_CL,
                    proxy=proxy,
                    proxy_cred=proxy_cred,
                    custom_user_agent=user_agent,
                    cookie=cookie,
                    host_header=host,
                    http_headers=headers,
                    random_user_agent=random_agent,
                    timeout=timeout,
                    api=api,
                    notext=notext,
                    verbosity=verbosity)
            if ((api is not True) and (notext is not True)):
                ConsoleOutput().Message_with_all_Findings(
                    findings_list)
            print(tcolor.purple +
                  '\n\n[*%*] Finished.' +
                  tcolor.endcolor)
        except KeyboardInterrupt:
            print('\nKeyboardInterrupt Detected.')
            print('\nExiting...')
            exit(0)

# *** END *** #
